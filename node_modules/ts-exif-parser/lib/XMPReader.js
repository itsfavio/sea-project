"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XMPReader = void 0;
var sax = require("sax");
var markerBegin = '<x:xmpmeta';
var markerEnd = '</x:xmpmeta>';
/* The text-content of these tags are ignored in the output */
var envelopeTags = [
    'x:xmpmeta',
    'rdf:RDF',
    'rdf:Description',
    'rdf:Bag',
    'rdf:Alt',
    'rdf:Seq',
    'rdf:li',
    'mwg-rs:RegionList'
];
/* Map the different meta keys to a single definition */
var keyTransform = {
    'mwg-rs:Regions': 'region',
    'MicrosoftPhoto:LastKeywordXMP': 'keywords',
    'MicrosoftPhoto:LastKeywordIPTC': 'keywords',
    'dc:subject': 'keywords',
    'MicrosoftPhoto:Rating': 'mRating',
    'cc:attributionName': 'attribution',
    'xmpRights:UsageTerms': 'terms',
    'dc:rights': 'terms'
};
var XMPReader = /** @class */ (function () {
    function XMPReader() {
    }
    XMPReader.capitalizeFirstLetter = function (string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    };
    XMPReader.lowercaseFirstLetter = function (string) {
        return string.charAt(0).toLowerCase() + string.slice(1);
    };
    XMPReader.getLastKeyFromPath = function (path) {
        return path.filter(function (p) { return envelopeTags.indexOf(p) < 0; }).pop();
    };
    ;
    XMPReader.getKeyFromPath = function (path) {
        var _this = this;
        return path
            .filter(function (p) { return envelopeTags.indexOf(p) < 0; })
            .map(function (p) { return keyTransform[p] || p; })
            .map(function (p) { return p.indexOf(':') >= 0 ? p.split(':')[1] : p; })
            .map(function (p, i) { return i == 0 ? _this.lowercaseFirstLetter(p) : _this.capitalizeFirstLetter(p); })
            .join('');
    };
    XMPReader.updateData = function (oldData, newData) {
        if (oldData === undefined) {
            return newData;
        }
        else {
            if (!Array.isArray(oldData)) {
                return [oldData, newData];
            }
            oldData.push(newData);
            return oldData;
        }
    };
    XMPReader.read = function (buffer) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var data = {
                raw: {}
            };
            var offsetBegin = buffer.indexOf(markerBegin);
            if (offsetBegin > 0) {
                var offsetEnd = buffer.indexOf(markerEnd);
                if (offsetEnd > 0) {
                    var xmlBuffer = buffer.slice(offsetBegin, offsetEnd + markerEnd.length);
                    var parser = sax.parser(true, {});
                    var nodeName_1;
                    var nodePath_1 = [];
                    parser.onerror = function (err) { return reject(err); };
                    parser.onend = function () { return resolve(data); };
                    parser.onopentag = function (node) {
                        nodeName_1 = node.name;
                        nodePath_1.push(node.name);
                    };
                    parser.onclosetag = function () {
                        nodePath_1.pop();
                    };
                    parser.ontext = function (text) {
                        if (text.trim() != '') {
                            var value;
                            switch (nodeName_1) {
                                case 'stArea:x':
                                case 'stArea:y':
                                case 'stArea:w':
                                case 'stArea:h':
                                    value = parseFloat(text);
                                    break;
                                case 'xmp:Rating':
                                    value = parseInt(text);
                                    break;
                                case 'MicrosoftPhoto:Rating':
                                    value = Math.floor((parseInt(text) + 12) / 25) + 1;
                                    break;
                                default:
                                    value = text;
                            }
                            var rawKey = _this.getLastKeyFromPath(nodePath_1);
                            data.raw[rawKey] = _this.updateData(data.raw[rawKey], value);
                            var key = _this.getKeyFromPath(nodePath_1);
                            data[key] = _this.updateData(data[key], value);
                        }
                    };
                    parser.write(xmlBuffer.toString('utf-8', 0, xmlBuffer.length)).close();
                }
                else
                    resolve(data);
            }
            else
                resolve(data);
        });
    };
    return XMPReader;
}());
exports.XMPReader = XMPReader;
//# sourceMappingURL=XMPReader.js.map